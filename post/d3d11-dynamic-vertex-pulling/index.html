<!DOCTYPE html>
<html lang="en-us">

<head>
<meta charset="utf-8" />
<meta name="author" content="Kirill Bazhenov" />
<meta name="description" content="Personal blog." />
<meta name="keywords" content="blog, tech" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.31.1" />

<link rel="canonical" href="https://bazhenovc.github.io/blog/post/d3d11-dynamic-vertex-pulling/">
<base href="https://bazhenovc.github.io/blog/" />
<meta property="og:title" content="Dynamic vertex pulling with D3D11" />
<meta property="og:description" content="This is crossposted from GameDev.net

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bazhenovc.github.io/blog/post/d3d11-dynamic-vertex-pulling/" />



<meta property="article:published_time" content="2017-02-02T02:33:31&#43;03:00"/>

<meta property="article:modified_time" content="2017-02-02T02:33:31&#43;03:00"/>











<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Dynamic vertex pulling with D3D11"/>
<meta name="twitter:description" content="This is crossposted from GameDev.net

"/>



<meta itemprop="name" content="Dynamic vertex pulling with D3D11">
<meta itemprop="description" content="This is crossposted from GameDev.net

">


<meta itemprop="datePublished" content="2017-02-02T02:33:31&#43;03:00" />
<meta itemprop="dateModified" content="2017-02-02T02:33:31&#43;03:00" />
<meta itemprop="wordCount" content="2058">



<meta itemprop="keywords" content="Direct3D,Direct3D 11," />


<link rel="stylesheet" href="css/layout.css" />
<style type="text/css">
body {
  background-color: #101010;
  color: #dbdbdb;
}

a { color: #dbdbdb; }

pre {
  background: #1D1F21;
  border: 1px solid #dbdbdb;
  border-radius: 5px;
}

code {
  background: #1D1F21;
}

blockquote {
  background: #1D1F21;
  border-left: 3px solid #dbdbdb;
}

table {
  margin: 1em auto;
  border-collapse: collapse;
}

table, th, td {
  border: 1px solid #dbdbdb;
}

th {
  background: #dbdbdb;
  color: #101010;
}

.siteTitle a { color: #99cc66; }

.post .content h1{ color: #99cc66; }
.post .content h2{ color: #99cc66; }
.post .content h3{ color: #99cc66; }
.post .content h4{ color: #99cc66; }
.post .content h5{ color: #99cc66; }
.post .content h6{ color: #99cc66; }
.post .content a:hover { color: #99cc66; }
.social-link:hover { color: #99cc66; }
.nav-item-title:hover { color: #99cc66; }
.tag a:hover { color: #99cc66; }
.copyright { color: #404040 }
.poweredby { color: #404040 }
.poweredby a { color: #404040; }
.post-preview .title a{ color: #99cc66; }
.content-item a:hover{
  text-decoration: underline;
  color: #99cc66;
}
.post-list .title { color: #99cc66; }
.rmore { color: #99cc66; }
.terms .term a:hover {
  text-decoration: underline;
  color: #99cc66;
}

</style>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-111358204-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


<title>


     Dynamic vertex pulling with D3D11 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://bazhenovc.github.io/blog/">bazhenovc</a>
    </div> 

    
    
    <a class="nav-item" href="https://bazhenovc.github.io/blog/post/"><div class="nav-item-title">Posts</div></a>
    
    <a class="nav-item" href="https://bazhenovc.github.io/blog/tags/"><div class="nav-item-title">Tags</div></a>
    

  </nav>
</div>

  
<div class="social-links-header">

  
  <a href="mailto:bazhenovc@gmail.com"><div class="social-link">email</div></a>
  

  
  <a href="https://github.com/bazhenovc" target="_blank"><div class="social-link">gh</div></a>
  

  

  

  

</div>


</header>


<article class="post">
    <h1 class="title"> Dynamic vertex pulling with D3D11 </h1>
    <div class="content"> <p>This is crossposted from <a href="http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/dynamic-vertex-pulling-with-d3d11-r4048">GameDev.net</a></p>

<p></p>

<h1 id="motivation">Motivation</h1>

<p>The motivation is very simple: regular hardware instancing is suddenly not enough for the current project. The reason for this is the amount of different trees, for which the simple arithmetic works:</p>

<ol>
<li>9 base types of trees</li>
<li>3 growth stages for each tree (a branch, a small tree and a big tree)</li>
<li>3 health stages for each growth stage for each tree (healthy, sick and dying)</li>
<li>5 LODs for each health stage for each growth stage for each tree (including impostors)</li>
<li>This creates a serious combinatorial explosion, which makes regular instancing a lot less effective.</li>
</ol>

<p>Below I suggest a solution that allows one to bypass this problem and to render all these different trees with a single draw call, while having a unique mesh and unique constants per each object.</p>

<h1 id="main-idea">Main idea</h1>

<p>D3D11 and GL4 support [RW]StructuredBuffer (D3D) and ARB_shader_storage_buffer_object (GL), which represent some GPU memory buffer with structured data. A shader can fetch the data from this buffer by an arbitrary index.</p>

<p>I suggest to use 2 global buffers to store vertices and indices and to fetch the data from there in a vertex shader using a vertex ID.</p>

<p>This way we can supply an offset to this buffer as a regular constant and start fetching vertices starting from this offset.</p>

<p>How do we implement this?</p>

<h1 id="logical-and-physical-buffers">Logical and physical buffers</h1>

<p>Let us introduce two terms: a physical buffer and a logical buffer.</p>

<p>A physical buffer is a GPU memory buffer which stores all indices and vertices of our geometry. Essentially it is a sort of a &ldquo;geometry atlas&rdquo; - we pack all our mesh data there.</p>

<p>A logical buffer is a data structure that contains physical buffer offset and a data block size.</p>

<p>In C++ this will look like this:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> DXLogicalMeshBuffer <span style="color:#66d9ef">final</span>
{
    uint8_t<span style="color:#f92672">*</span> data             <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    size_t   dataSize         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    size_t   dataFormatStride <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    size_t   physicalAddress  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};</code></pre></div>

<p>The struct fields are used for:</p>

<ul>
<li>data : a pointer to the buffer data</li>
<li>dataSize : Buffer data size in bytes</li>
<li>dataFormatStride : One buffer element size</li>
<li>physicalAddress : Physical buffer offset, by which this buffer data is located. This field is set when physical buffer is updated (see below)</li>
</ul>

<p>Upon logical buffer creation a physical buffer must know about the logical buffer to create a storage space for it.</p>

<p>Physical buffer class looks like this:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> DXPhysicalMeshBuffer <span style="color:#66d9ef">final</span>
{
    ID3D11Buffer<span style="color:#f92672">*</span>             physicalBuffer     <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    ID3D11ShaderResourceView<span style="color:#f92672">*</span> physicalBufferView <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    size_t                    physicalDataSize   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">bool</span>                      isDirty            <span style="color:#f92672">=</span> false;

    <span style="color:#66d9ef">typedef</span> DynamicArray<span style="color:#f92672">&lt;</span>DXLogicalMeshBuffer<span style="color:#f92672">*&gt;</span> PageArray;
    PageArray allPages;

    DXPhysicalMeshBuffer() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#66d9ef">inline</span> <span style="color:#f92672">~</span>DXPhysicalMeshBuffer()
    {
        <span style="color:#66d9ef">if</span> (physicalBuffer <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)     physicalBuffer<span style="color:#f92672">-&gt;</span>Release();
        <span style="color:#66d9ef">if</span> (physicalBufferView <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) physicalBufferView<span style="color:#f92672">-&gt;</span>Release();
    }

    <span style="color:#66d9ef">void</span> allocate(DXLogicalMeshBuffer<span style="color:#f92672">*</span> logicalBuffer);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">release</span>(DXLogicalMeshBuffer<span style="color:#f92672">*</span> logicalBuffer);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rebuildPages</span>(); <span style="color:#75715e">// very expensive operation
</span><span style="color:#75715e"></span>}</code></pre></div>

<p>The class fields are used for:</p>

<ul>
<li>physicalBuffer : An actual buffer with the data</li>
<li>physicalBufferView : A shader resource view for shader data access</li>
<li>physicalDataSize : Buffer data size in bytes</li>
<li>isDirty : A flag that indicates the need for buffer update (it is needed after each logical buffer allocation/deallocation).</li>
<li>allPages : All logical buffers allocated inside this physical buffer.</li>
</ul>

<p>Each time a logical buffer is allocated/freed a physical buffer needs to be informed about this. Allocate/release operations are quite trivial:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> DXPhysicalBuffer<span style="color:#f92672">::</span>allocate(DXLogicalMeshBuffer<span style="color:#f92672">*</span> logicalBuffer)
{
    allPages.Add(logicalBuffer);
    isDirty <span style="color:#f92672">=</span> true;
}

<span style="color:#66d9ef">void</span> DXPhysicalBuffer<span style="color:#f92672">::</span>release(DXLogicalMeshBuffer<span style="color:#f92672">*</span> logicalBuffer)
{
    allPages.Remove(logicalBuffer);
    isDirty <span style="color:#f92672">=</span> true;
}</code></pre></div>

<p>rebuildPages() method is much more interesting.</p>

<p>This method must create a physical buffer and fill it with the data from all used logical buffers. A physical buffer must be mappable to RAM and bindable as a structured shader resource.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">size_t vfStride <span style="color:#f92672">=</span> allPages[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>dataFormatStride; <span style="color:#75715e">// TODO: right now will not work with different strides
</span><span style="color:#75715e"></span>size_t numElements <span style="color:#f92672">=</span> physicalDataSize <span style="color:#f92672">/</span> vfStride;

<span style="color:#66d9ef">if</span> (physicalBuffer <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)     physicalBuffer<span style="color:#f92672">-&gt;</span>Release();
<span style="color:#66d9ef">if</span> (physicalBufferView <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) physicalBufferView<span style="color:#f92672">-&gt;</span>Release();

D3D11_BUFFER_DESC bufferDesc;
bufferDesc.BindFlags           <span style="color:#f92672">=</span> D3D11_BIND_SHADER_RESOURCE;
bufferDesc.ByteWidth           <span style="color:#f92672">=</span> physicalDataSize;
bufferDesc.Usage               <span style="color:#f92672">=</span> D3D11_USAGE_DYNAMIC;
bufferDesc.MiscFlags           <span style="color:#f92672">=</span> D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
bufferDesc.StructureByteStride <span style="color:#f92672">=</span> vfStride;
bufferDesc.CPUAccessFlags      <span style="color:#f92672">=</span> D3D11_CPU_ACCESS_WRITE;

<span style="color:#66d9ef">if</span> (FAILED(g_pd3dDevice<span style="color:#f92672">-&gt;</span>CreateBuffer(<span style="color:#f92672">&amp;</span>bufferDesc, <span style="color:#66d9ef">nullptr</span>, <span style="color:#f92672">&amp;</span>physicalBuffer))) {
    handleError(...); <span style="color:#75715e">// handle your error here
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}</code></pre></div>

<p>Make sure that StructureByteStride is equal to the size of a structure read by the vertex shader. Also, CPU write access is required.</p>

<p>After that we need to create a shader resource view:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
std<span style="color:#f92672">::</span>memset(<span style="color:#f92672">&amp;</span>viewDesc, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(viewDesc));

viewDesc.Format              <span style="color:#f92672">=</span> DXGI_FORMAT_UNKNOWN;
viewDesc.ViewDimension       <span style="color:#f92672">=</span> D3D11_SRV_DIMENSION_BUFFER;
viewDesc.Buffer.ElementWidth <span style="color:#f92672">=</span> numElements;

<span style="color:#66d9ef">if</span> (FAILED(g_pd3dDevice<span style="color:#f92672">-&gt;</span>CreateShaderResourceView(physicalBuffer, <span style="color:#f92672">&amp;</span>viewDesc, <span style="color:#f92672">&amp;</span>physicalBufferView)))
{
    <span style="color:#75715e">// TODO: error handling
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}</code></pre></div>

<p>Whew. Now let us get straight to the physical buffer filling! The algorithm is:</p>

<ol>
<li>Map the physical buffer to RAM.</li>
<li>for each logical buffer:</li>
<li>Calculate logical buffer offset into the physical buffer (physicalAddress field).</li>
<li>Copy the data from the logical buffer to the mapped memory with the needed offset.</li>
<li>Go to the next logical buffer.</li>
<li>Unmap the physical buffer.</li>
</ol>

<p>The code is quite simple:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// fill the physical buffer
</span><span style="color:#75715e"></span>D3D11_MAPPED_SUBRESOURCE mappedData;
std<span style="color:#f92672">::</span>memset(<span style="color:#f92672">&amp;</span>mappedData, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(mappedData));

<span style="color:#66d9ef">if</span> (FAILED(g_pImmediateContext<span style="color:#f92672">-&gt;</span>Map(physicalBuffer, <span style="color:#ae81ff">0</span>, D3D11_MAP_WRITE_DISCARD, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>mappedData)))
{
    handleError(...); <span style="color:#75715e">// insert error handling here
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}

uint8_t<span style="color:#f92672">*</span> dataPtr <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>uint8_t<span style="color:#f92672">*&gt;</span>(mappedData.pData);
size_t pageOffset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> allPages.GetSize(); <span style="color:#f92672">++</span>i) {
    DXLogicalMeshBuffer<span style="color:#f92672">*</span> logicalBuffer <span style="color:#f92672">=</span> allPages[i];
    <span style="color:#75715e">// copy logical data to the mapped physical data
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>memcpy(dataPtr <span style="color:#f92672">+</span> pageOffset, logicalBuffer<span style="color:#f92672">-&gt;</span>data, logicalBuffer<span style="color:#f92672">-&gt;</span>dataSize);
    <span style="color:#75715e">// calculate physical address
</span><span style="color:#75715e"></span>    logicalBuffer<span style="color:#f92672">-&gt;</span>physicalAddress <span style="color:#f92672">=</span> pageOffset <span style="color:#f92672">/</span> logicalBuffer<span style="color:#f92672">-&gt;</span>dataFormatStride;
    <span style="color:#75715e">// calculate offset
</span><span style="color:#75715e"></span>    pageOffset <span style="color:#f92672">+=</span> logicalBuffer<span style="color:#f92672">-&gt;</span>dataSize;
}

g_pImmediateContext<span style="color:#f92672">-&gt;</span>Unmap(physicalBuffer, <span style="color:#ae81ff">0</span>);</code></pre></div>

<p>Note that rebuilding a physical buffer is a very expensive operation, in our case it is around 500ms. This slowness is caused by the high amount of data that is being sent to the GPU (tens of megabytes!). This why it is not recommended to rebuild the physical buffer often.</p>

<p><a href="https://github.com/bazhenovc/sigrlinn/blob/master/demo/demo_grass.cc#L127">Full code for rebuildPages() method for reference.</a></p>

<p>Storing and rendering stuff like that requires a custom constant managing as well.</p>

<h1 id="managing-per-object-constants">Managing per-object constants</h1>

<p>Traditional constant buffers does not fit here for obvious reasons. That&rsquo;s why there is no other choice then to use one more global buffer, similar to the physical buffer described above.</p>

<p>Apart from usual shader constants this buffer must contain logical buffer information, geometry type (indexed and non-indexed) and vertex count.</p>

<p>Creating this buffer is trivial:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>memset(<span style="color:#f92672">&amp;</span>bufferDesc, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(bufferDesc));

bufferDesc.BindFlags           <span style="color:#f92672">=</span> D3D11_BIND_SHADER_RESOURCE;
bufferDesc.ByteWidth           <span style="color:#f92672">=</span> dataBufferSize;
bufferDesc.Usage               <span style="color:#f92672">=</span> D3D11_USAGE_DYNAMIC;
bufferDesc.MiscFlags           <span style="color:#f92672">=</span> D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
bufferDesc.StructureByteStride <span style="color:#f92672">=</span> stride;
bufferDesc.CPUAccessFlags      <span style="color:#f92672">=</span> D3D11_CPU_ACCESS_WRITE;

<span style="color:#66d9ef">if</span> (FAILED(g_pd3dDevice<span style="color:#f92672">-&gt;</span>CreateBuffer(<span style="color:#f92672">&amp;</span>bufferDesc, <span style="color:#66d9ef">nullptr</span>, <span style="color:#f92672">&amp;</span>dataBuffer))) {
    handleError(...); <span style="color:#75715e">// handle your error here
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}

D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
std<span style="color:#f92672">::</span>memset(<span style="color:#f92672">&amp;</span>viewDesc, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(viewDesc));

viewDesc.Format              <span style="color:#f92672">=</span> DXGI_FORMAT_UNKNOWN;
viewDesc.ViewDimension       <span style="color:#f92672">=</span> D3D11_SRV_DIMENSION_BUFFER;
viewDesc.Buffer.ElementWidth <span style="color:#f92672">=</span> numInstances;

<span style="color:#66d9ef">if</span> (FAILED(g_pd3dDevice<span style="color:#f92672">-&gt;</span>CreateShaderResourceView(dataBuffer, <span style="color:#f92672">&amp;</span>viewDesc, <span style="color:#f92672">&amp;</span>dataView))) {
    handleError(...); <span style="color:#75715e">// handle your error here
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}</code></pre></div>

<p>First, four 32-bit registers of this buffer are filled with a shader internal data used for rendering. This data looks like this:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> InternalData
{
    uint32_t vb;
    uint32_t ib;
    uint32_t drawCallType;
    uint32_t count;
};</code></pre></div>

<p>After this structure goes the usual constant data used for generic mesh rendering (such as projection matrix).</p>

<p>Now a small digression. I usually don&rsquo;t render anything directly, instead I use an array of DrawCall structures, which also contain constants and all other data needed for a single DIP:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> DrawCall <span style="color:#66d9ef">final</span>
{
    <span style="color:#66d9ef">enum</span> Type : uint32_t
    {
        Draw        <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
        DrawIndexed <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    };

    <span style="color:#66d9ef">enum</span>
    {
        ConstantBufferSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">2048</span> <span style="color:#75715e">// TODO: remove hardcode
</span><span style="color:#75715e"></span>    };

    <span style="color:#66d9ef">enum</span>
    {
        MaxTextures <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
    };

    uint8_t constantBufferData[ConstantBufferSize];

    DXLogicalMeshBuffer<span style="color:#f92672">*</span> vertexBuffer;
    DXLogicalMeshBuffer<span style="color:#f92672">*</span> indexBuffer;

    uint32_t count;
    uint32_t startVertex;
    uint32_t startIndex;
    Type     type;
};</code></pre></div>

<p>This is simplified to make reading easier.</p>

<p>The application fills an array of these structures and submits them for rendering.</p>

<p>After filling this draw call buffer we need to update the constant buffer, update InternalData and, finally, issue a real DIP to render stuff.</p>

<p>Updating constants is trivial, just loop through the command buffer and copy needed data to the right place:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// update constants
</span><span style="color:#75715e"></span>{
    D3D11_MAPPED_SUBRESOURCE mappedData;
    <span style="color:#66d9ef">if</span> (FAILED(g_pImmediateContext<span style="color:#f92672">-&gt;</span>Map(psimpl<span style="color:#f92672">-&gt;</span>constantBuffer.dataBuffer, <span style="color:#ae81ff">0</span>, D3D11_MAP_WRITE_DISCARD,
      <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>mappedData))) {
        <span style="color:#75715e">// TODO: error handling
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
    }
    uint8_t<span style="color:#f92672">*</span> dataPtr <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>uint8_t<span style="color:#f92672">*&gt;</span>(mappedData.pData);
    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> numInstances; <span style="color:#f92672">++</span>i) {
        size_t offset <span style="color:#f92672">=</span> i <span style="color:#f92672">*</span> internal<span style="color:#f92672">::</span>DrawCall<span style="color:#f92672">::</span>ConstantBufferSize;
        <span style="color:#66d9ef">const</span> internal<span style="color:#f92672">::</span>DrawCall<span style="color:#f92672">&amp;</span> call <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>getDrawCalls()[i];

        std<span style="color:#f92672">::</span>memcpy(dataPtr <span style="color:#f92672">+</span> offset, call.constantBufferData, internal<span style="color:#f92672">::</span>DrawCall<span style="color:#f92672">::</span>ConstantBufferSize);

        <span style="color:#75715e">// fill internal data structure
</span><span style="color:#75715e"></span>        InternalData<span style="color:#f92672">*</span> idata <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>InternalData<span style="color:#f92672">*&gt;</span>(dataPtr <span style="color:#f92672">+</span> offset);

        DXLogicalMeshBuffer<span style="color:#f92672">*</span> vertexBuffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>DXLogicalMeshBuffer<span style="color:#f92672">*&gt;</span>(call.vertexBuffer.value);
        <span style="color:#66d9ef">if</span> (vertexBuffer <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
            idata<span style="color:#f92672">-&gt;</span>vb <span style="color:#f92672">=</span> vertexBuffer<span style="color:#f92672">-&gt;</span>physicalAddress;

        DXLogicalMeshBuffer<span style="color:#f92672">*</span> indexBuffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>DXLogicalMeshBuffer<span style="color:#f92672">*&gt;</span>(call.indexBuffer.value);
        <span style="color:#66d9ef">if</span> (indexBuffer <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
            idata<span style="color:#f92672">-&gt;</span>ib <span style="color:#f92672">=</span> indexBuffer<span style="color:#f92672">-&gt;</span>physicalAddress;

        idata<span style="color:#f92672">-&gt;</span>drawCallType <span style="color:#f92672">=</span> call.type;
        idata<span style="color:#f92672">-&gt;</span>count        <span style="color:#f92672">=</span> call.count;
    }
    g_pImmediateContext<span style="color:#f92672">-&gt;</span>Unmap(psimpl<span style="color:#f92672">-&gt;</span>constantBuffer.dataBuffer, <span style="color:#ae81ff">0</span>);
}</code></pre></div>

<p>The data is now ready for actual rendering.</p>

<h1 id="shader-and-drawing">Shader and drawing</h1>

<p>Time for drawing! To render everything we need to set the buffers and issue DrawInstanced:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ID3D11ShaderResourceView<span style="color:#f92672">*</span> vbibViews[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {
    g_physicalVertexBuffer<span style="color:#f92672">-&gt;</span>physicalBufferView,
    g_physicalIndexBuffer<span style="color:#f92672">-&gt;</span>physicalBufferView
};

g_pImmediateContext<span style="color:#f92672">-&gt;</span>VSSetShaderResources(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, vbibViews);

g_pImmediateContext<span style="color:#f92672">-&gt;</span>VSSetShaderResources(<span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>psimpl<span style="color:#f92672">-&gt;</span>constantBuffer.dataView);
g_pImmediateContext<span style="color:#f92672">-&gt;</span>HSSetShaderResources(<span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>psimpl<span style="color:#f92672">-&gt;</span>constantBuffer.dataView);
g_pImmediateContext<span style="color:#f92672">-&gt;</span>DSSetShaderResources(<span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>psimpl<span style="color:#f92672">-&gt;</span>constantBuffer.dataView);
g_pImmediateContext<span style="color:#f92672">-&gt;</span>GSSetShaderResources(<span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>psimpl<span style="color:#f92672">-&gt;</span>constantBuffer.dataView);
g_pImmediateContext<span style="color:#f92672">-&gt;</span>PSSetShaderResources(<span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>psimpl<span style="color:#f92672">-&gt;</span>constantBuffer.dataView);

g_pImmediateContext<span style="color:#f92672">-&gt;</span>DrawInstanced(maxDrawCallVertexCount, numInstances, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);</code></pre></div>

<p>Almost done. A few notes:</p>

<ul>
<li>DrawInstanced needs to be called with a maximum amount of vertices the command buffer has. This is required because we have a single draw call and several meshes. Meshes can have different amount of vertices/indices and this needs to be taken into account. I suggest to render the maximum amount of vertices and discard redundant vertices by sending them outside the clip plane.</li>
<li>This introduces some additional vertex shader overhead, thus you need to carefully watch for the difference between maximum and minimum vertices being within a reasonable range (typically 10% difference is OK). Remember that these wasted vertices add overhead to each rendered instance and it grows insanely fast. Watch for the artists!</li>
<li>One DrawInstanced call can handle both indexed and non-indexed geometry, because this is handled in the vertex shader. TriangleStrip, TriangleFan and similar topologies are not supported for obvious reasons. This method supports only *List topologies (TriangleList, PointList, etc.)</li>
</ul>

<p>The vertex shader is also very simple.</p>

<p>First we need to define all the CPU-side structured (vertex format, constant format, etc.):</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hlsl" data-lang="hlsl">// vertex
struct VertexData
{
    float3 position;
    float2 texcoord0;
    float2 texcoord1;
    float3 normal;
};
StructuredBuffer&lt;VertexData&gt; g_VertexBuffer;
StructuredBuffer&lt;uint&gt;       g_IndexBuffer;

// pipeline state
#define DRAW 0
#define DRAW_INDEXED 1
struct ConstantData
{
    uint4    internalData;

    float4x4 World;
    float4x4 View;
    float4x4 Projection;
};
StructuredBuffer&lt;ConstantData&gt; g_ConstantBuffer;</code></pre></div>

<p>After that goes the code that fetches constant data and processes vertices (pay attention to indexed/non-indexed geometry handling):</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hlsl" data-lang="hlsl">uint instanceID = input.instanceID;
uint vertexID   = input.vertexID;

uint vbID      = g_ConstantBuffer[instanceID].internalData[0];
uint ibID      = g_ConstantBuffer[instanceID].internalData[1];
uint drawType  = g_ConstantBuffer[instanceID].internalData[2];
uint drawCount = g_ConstantBuffer[instanceID].internalData[3];

VertexData vdata;
[branch] if (drawType == DRAW_INDEXED) vdata = g_VertexBuffer[vbID + g_IndexBuffer[ibID + vertexID]];
else     if (drawType == DRAW)         vdata = g_VertexBuffer[vbID + vertexID];

[flatten] if (vertexID &gt; drawCount)
    vdata = g_VertexOutsideClipPlane; // discard vertex by moving it outside of the clip plane</code></pre></div>

<p>As you can see - there is no rocket science. <a href="https://github.com/bazhenovc/sigrlinn/blob/master/shaders/dvp.hlsl">Full shader code for reference.</a></p>

<p>An attentive reader will notice that I did not cover texturing. The next part is about it.</p>

<h1 id="what-shall-we-do-with-textures">What shall we do with textures?</h1>

<p>This is the biggest con of this method. With this approach it is highly desired to have unique textures per instance, but implementing this with D3D11 is problematic.</p>

<p>Possible solutions:</p>

<ul>
<li>Use one texture atlas. Cons: One atlas cannot hold many textures, so you will need to batch instances by 3 or 4 and render them separately. This negates all the pros of this method.</li>
<li>Use texture arrays (Texture2DArray, Sampler2DArray). Cons: better then texture atlas, but still limited to 2048 textures per array.</li>
<li>Switch to OpenGL 4.3 with bindless textures. Cons: everything will fit, but there is one serious problem called OpenGL.</li>
<li>Switch to D3D12/Mantle/Vulkan/etc. Cons: everything will fit, but with limited hardware/OS support.</li>
<li>Virtual textures. Cons: virtual textures, anyone?:)</li>
</ul>

<p>Detailed overview of all these methods goes beyond this article. I will only say that I use texture arrays for D3D11 and native features of D3D12.</p>

<h1 id="caveats-and-limitations">Caveats and limitations</h1>

<p>All major cons are described above, thus here is a little summary:</p>

<ul>
<li>Wasted vertices overhead.</li>
<li>Indirection overhead: vertex and constant access is badly predicted, because it is a random access, thus they are not cached and always calculated dynamically. Indexed rendering is the slowest one because of double indirection.</li>
<li>Not all primitive topologies supported.</li>
<li>Unique textures per instance are not possible in the general case.</li>
<li>Reallocating buffers is expensive and adds video memory fragmentation.</li>
<li>Unusual vertex buffers require unusual algorithms for unusual cases, like dynamically generating vertices with compute shader (e.g. water simulation, cloth, etc.).</li>

<li><p>It is required to hold all the logical buffer data in memory, this slightly increasing application memory consumption.</p>

<h1 id="demo-and-sources">Demo and sources</h1></li>
</ul>

<p>The main source code for this method is <a href="https://github.com/bazhenovc/sigrlinn/blob/master/demo/demo_grass.cc">here</a>. There is no binary version at the moment.</p>

<p>Here are some screenshots:
16384 unique cubes, 1.2ms per frame on Intel HD 4400:</p>

<p><img src="https://bazhenovc.github.io/blog/dvp_cubes.png" alt="cubes" /></p>

<p>4096 unique instances of grass, 200k triangles:</p>

<p><img src="https://bazhenovc.github.io/blog/dvp_grass.png" alt="grass" /></p>

<h1 id="further-reading">Further reading</h1>

<p><a href="http://openglinsights.com/bendingthepipeline.html#ProgrammableVertexPulling">OpenGL Insights, III Bending the Pipeline, Programmable vertex pulling by Daniel Rakos</a> - almost the same method for OpenGL.</p>

<p>Thanks for your attention!</p> </div>
    <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
      <div class="tag">
        <a href="https://bazhenovc.github.io/blog/tags/direct3d">#Direct3D</a>
      </div>
    
      <div class="tag">
        <a href="https://bazhenovc.github.io/blog/tags/direct3d-11">#Direct3D 11</a>
      </div>
    
</div>

    <div class="date"> Feb 2, 2017 </div>
  </div>

</footer>


  


</article>

  <footer>

  <div class="social-links-footer">

  
  <a href="mailto:bazhenovc@gmail.com"><div class="social-link">Email</div></a>
  

  
  <a href="https://github.com/bazhenovc" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  <div class="social-link">
  <a href="https://bazhenovc.github.io/blog/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright"> Copyright (c) 2017, all rights reserved. </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

</body>
</html>

